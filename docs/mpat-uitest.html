<!DOCTYPE html>
<html>

<head>
  <title>moteus Perfomance Analysis Tool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-size: 14px;
      font-family: system-ui, sans-serif;
      color: #333;
      background: #fcfcfc;
      margin: 0;
      padding: 1 rem;
      padding-bottom: 2.5em;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      table-layout: auto;
    }
    td, th {
      border: none;
      padding: 0.3rem;
      text-align: left;
    }
    th {
      font-weight: 600;
    }
    td {
      border-top: 1px solid #eee;
    }
    td:nth-child(odd) {
      background-color:#f9fafb;
    }

    td:nth-child(even) {
      background-color: #ffffff;
    }

    th:nth-child(odd) {
      background-color: #f1f5f9;
    }
    th:nth-child(even) {
      background-color: #f5f9fa;
    }

    footer {
      position: fixed;
      bottom: 0;
      width: 100%;
      background: #f1f1f1;
      padding: 10px;
      text-align: center;
      font-size: 0.9em;
      border-top: 1px solid #ccc;
    }

    .pageContainer {
      display: flex;
      flex-wrap: wrap;
      gap: 0.2rem;
    }

    .panelColumn {
      flex: 1 1 300px;
      max-width: 400px;
      min-width: 200px;
      padding: 1em;
    }

    .resultsColumn {
      flex: 2 1 500px;
      min-width: 200px;
      padding: 1em;
    }

    .panelContainer {
      border: 1px solid #ddd;
      border-radius: 3px;
      margin: 0.4em 0;
      background: white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
      /*overflow: hidden;*/
    }

    .panelContent {
      padding: 1rem;
    }

    .configField {
      margin-bottom: 0.75rem;
    }

    .configField:last-child {
      margin-bottom: 0;
    }

    .panelTitle {
      cursor: pointer;
      padding: 0.5rem;
      background:#f7f9fc;
      font-weight: 600;
      border-bottom: 1px solid #eee;
    }

    .resultTable {
      display: inline-block;
      max-width: 100%;
      margin: 1 rem auto;
      background: white;
      border-radius: 5px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
    }

    .multiHeader {
      font-weight: 600;
    }

    .overlayContainer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.0);
      z-index: 1000;
      outline: 1px dashed red;
      pointer-events: none;
    }

    .overlayBody {
      position: fixed;
      top: 0;
      right: 0;
      width: 300px;
      height: 100%;
      background: white;
      borderLeft: 1px solid #ccc;
      padding: 1rem;
      box-shadow: -2px 0px 8px rgba(0, 0, 0, 0.2);
      pointer-events: auto;
    }

    @media (max-width: 600px) {
      .overlayBody {
        left: 5px;
        right: 5px;
        top: 5px;
        bottom: 5px;
        border-left: none;
        box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.2);
      }
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "preact":                 "https://esm.sh/preact@10.26.5",
      "preact/":                "https://esm.sh/preact@10.26.5/",
      "preact/hooks":           "https://esm.sh/preact@10.26.5/hooks",
      "preact/compat":          "https://esm.sh/preact@10.26.5/compat",
      "preact/jsx-runtime":     "https://esm.sh/preact@10.26.5/jsx-runtime",

      "react": "https://esm.sh/preact@10.26.5/compat",
	  "react/": "https://esm.sh/preact@10.26.5/compat/",
	  "react-dom": "https://esm.sh/preact@10.26.5/compat",
      "react-dom/":           "https://esm.sh/preact@10.26.5/compat/",
      "react/jsx-runtime":    "https://esm.sh/preact@10.26.5/jsx-runtime",
      "react/jsx-dev-runtime":"https://esm.sh/preact@10.26.5/jsx-runtime",
      "react-dom/client":     "https://esm.sh/preact@10.26.5/compat",

      "htm": "https://esm.sh/htm@3.1.1",
      "react-select": "https://esm.sh/react-select@5?alias=react:preact/compat,react-dom:preact/compat&deps=preact@10.26.5",
      "react-select/creatable": "https://esm.sh/react-select@5/creatable?alias=react:preact/compat,react-dom:preact/compat&deps=preact@10.26.5"

    }
  }
</script>
  <script>
    // Embed the contents of preact, preact-hooks, and htm.
    // preact 10.26.5 - MIT License: https://github.com/preactjs/preact/blob/main/LICENSE
    // htm 3.1.1 - Apache 2.0 License: https://github.com/developit/htm/blob/master/LICENSE
    //
    // These were generated by:
    //  curl -L https://unpkg.com/preact@10.26.5/dist/preact.umd.js -o preact.umd.js
    //  curl -L https://unpkg.com/preact@10.26.5/hooks/dist/hooks.umd.js -o preact-hooks.umd.js
    //  curl -L https://unpkg.com/htm@3.1.1/dist/htm.umd.js -o htm.umd.js
  </script>
  <script type="module">
    // Copyright 2025 mjbots Robotic Systems, LLC.  info@mjbots.com
    //
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    //
    //     http://www.apache.org/licenses/LICENSE-2.0
    //
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.

    import {h, render } from "preact";
    import { useState, useEffect } from "preact/hooks";
    import htm from "htm";
    import Creatable from "react-select/creatable";

    const html = htm.bind(h);

/* ---------- helpers ---------- */
const parseKV = (txt) => {
  const [field, val] = txt.split('=');
  if (!field) return null;  // must have at least a field name
  if (val === undefined) {
    // No '=' found, treat as simple field
    return { field, value: field, label: field };
  }
  // '=' found (val could be empty string)
  return { field, value: field, data: val, label: `${field}=${val}` };
};

// Default values for common config - this defines all available fields
const defaultCommonValues = {
  'controller': 'moteus-x1',
  'controller_cooling': 'none',
  'motor': 'mad8318',
  'motor_cooling': 'none',
  'voltage': '24',
  'velocity': '0',
  'pwm': 'default',
  'supply_power': 'unlimited',
  'supply_current': 'unlimited',
  'time': 'infinity',
  'gear_ratio': '1',
  'ambient_temp': '25',
  'max_controller_temp': 'default',
  'max_motor_temp': 'default',
  'torque': 0,
  'output': 'torque',
  'analysis': "max_torque", // 'max_speed', 'operating_point'
};

// Default values for motor sub-fields
const motorSubFieldDefaults = {
  'motor.kv': '100',
  'motor.r': '0.1',
  'motor.l': '1e-6',
  'motor.mass': '0.1',
  'motor.diameter': '30',
  'motor.type': 'outrunner'
};

/* Field-specific value suggestions - only for constrained fields */
const fieldValueOptions = {
  'controller': [
    'moteus-c1',
    'moteus-r4',
    'moteus-n1',
    'moteus-x1',
    'odrive-micro',
    'odrive-s1',
    'odrive-pro',
  ],
  'controller_cooling': [
    'none',
    'heatspreader',
    '4030sink',
    'fan_5v',
    'fan_12v',
    'max',
  ],
  'motor': [
    'mad8318',
    'mj5208',
    'gbm5208',
    'be8108',
    'model',
    'extrapolated',
  ],
  'motor_cooling': [
    'none',
    'max',
  ],
  'analysis': [
    'max_torque',
    'max_speed',
    'operating_point',
  ],
  'output': [
    'torque',
    'speed',
    'power',
    'controller_temperature',
    'motor_temperature',
    'supply_power',
    'supply_current',
    'phase_current',
    'copper_loss',
    'iron_loss',
    'controller_loss',
    'mechanical_power',
    'efficiency',
  ],
  'motor.type': [
    'outrunner',
    'inrunner'
  ]
};

/* Motor model sub-field configurations */
const motorModelFields = {
  'model': ['kv', 'r', 'l', 'mass'],
  'extrapolated': ['kv', 'mass', 'diameter', 'type']
};

/* Generate dynamic sub-fields based on selected values */
const generateDynamicFields = (selectedValues) => {
  const dynamicFields = [];
  
  selectedValues.forEach(selected => {
    if (selected.field === 'motor' && selected.data) {
      const subFields = motorModelFields[selected.data];
      if (subFields) {
        subFields.forEach(subField => {
          const fullFieldName = `motor.${subField}`;
          dynamicFields.push({
            field: fullFieldName,
            value: fullFieldName,
            label: fullFieldName
          });
        });
      }
    }
  });
  
  return dynamicFields;
};

/* shared base fields for all selectors - derived from default values */
const getBaseFields = (selectedValues) => {
  const staticFields = Object.keys(defaultCommonValues).map(name => ({
    field: name,
    value: name,
    label: name
  }));
  
  const dynamicFields = generateDynamicFields(selectedValues);
  
  return [...staticFields, ...dynamicFields];
};

/* ---------- Model Classes ---------- */

function bisectMaxTrue(M, metric, threshold) {
  let lo = 0;
  let hi = M;

  if (!metric(0)) {
    return null;
  }

  if (metric(M)) {
    return M;
  }

  // Invariant: metric(lo) === true, metric(hi) === false, lo < hi
  while (lo < (hi - threshold)) {
    const mid = 0.5 * (lo + hi);
    if (metric(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }

  return lo;
}

class Interpolator2D {
  constructor(xlabels, ylabels, data) {
    this.xlabels = xlabels;
    this.ylabels = ylabels;
    this.data = data;

    // Validate that our data has the right number of rows and columns.
    if (data.length != this.ylabels.length) {
      throw new Error("Data matrix does not match label row count");
    }
    data.map((row) => {
      if (row.length != this.xlabels.length) {
        throw new Error("Data matrix does not match label column count");
      }
    });
  }

  // Also from 4o:
  //
  // Return a linear interpolation between nearest points, or if the
  // requested point is outside the allowed bounds, just extend the
  // nearest edge or corner indefinitely.
  interpolate(x, y) {
    // Helper function: Given a sorted label array and a value, returns
    // the lower and upper indices and the interpolation factor.
    function getInterval(labels, value) {
      const n = labels.length;
      if (value <= labels[0]) {
        return { indexLow: 0, indexHigh: 0, t: 0 };
      }
      if (value >= labels[n - 1]) {
        return { indexLow: n - 1, indexHigh: n - 1, t: 0 };
      }
      // Find the interval where labels[i] <= value <= labels[i+1]
      for (let i = 0; i < n - 1; i++) {
        if (value >= labels[i] && value <= labels[i + 1]) {
          let t = (value - labels[i]) / (labels[i + 1] - labels[i]);
          return { indexLow: i, indexHigh: i + 1, t: t };
        }
      }
      // Fallback (should never be reached)
      return { indexLow: n - 1, indexHigh: n - 1, t: 0 };
    }

    // Get the intervals and interpolation factors for x and y.
    const xInterval = getInterval(this.xlabels, x);
    const yInterval = getInterval(this.ylabels, y);

    const i0 = xInterval.indexLow;
    const i1 = xInterval.indexHigh;
    const t = xInterval.t;

    const j0 = yInterval.indexLow;
    const j1 = yInterval.indexHigh;
    const u = yInterval.t;

    // Retrieve the four surrounding grid values.
    const v00 = this.data[j0][i0];
    const v01 = this.data[j0][i1];
    const v10 = this.data[j1][i0];
    const v11 = this.data[j1][i1];

    // Interpolate along x for the two rows.
    const interpX0 = (1 - t) * v00 + t * v01;
    const interpX1 = (1 - t) * v10 + t * v11;

    // Interpolate the two results along y.
    return (1 - u) * interpX0 + u * interpX1;
  }
}

class Controller {
  constructor(props, power, thermal) {
    this.props = props;
    this.power = power;
    this.thermal = thermal;
    this.k0 = new Interpolator2D(this.power.voltages, this.power.pwms, this.power.k0);
    this.k1 = new Interpolator2D(this.power.voltages, this.power.pwms, this.power.k1);
    this.k2 = new Interpolator2D(this.power.voltages, this.power.pwms, this.power.k2);
  }

  getState() {
    return {};
  }

  getThermalProperties(state, coolingName) {
    if (this.thermal?.[coolingName] == null) {
      return [null, null];
    }
    return [this.thermal[coolingName]['R'], this.thermal[coolingName]['C']];
  }

  getMaxTemp() {
    return this.props['maxTemp'];
  }

  getMaxVoltage() {
    return this.props['maxVoltage'];
  }

  getMaxSpeed(state, voltage, voltageState, motor, motorState) {
    return voltage.getVoltage(voltageState) * motor.getKv(motorState) * this.getSpeedFactor() / 60.0;
  }

  getCurrentFromThermalPower(state, thermalW, {voltage, pwm}) {
    const [k0,k1,k2] = [
      this.k0.interpolate(voltage, pwm),
      this.k1.interpolate(voltage, pwm),
      this.k2.interpolate(voltage, pwm),
    ];
    const c = k0;
    const b = k1;
    const a = k2;

    return Math.min(this.getMaxCurrent(state, voltage),
      (-b + Math.sqrt(Math.max(0, b * b - 4 * a * (c - thermalW)))) / (2 * a));
  }

  getThermalPower(state, {voltage, pwm, current}) {
    const [k0, k1, k2] = [
      this.k0.interpolate(voltage, pwm),
      this.k1.interpolate(voltage, pwm),
      this.k2.interpolate(voltage, pwm),
    ];

    const thermalPower = k0 + k1 * current + k2 * current * current;
    return thermalPower;
  }

  getTemperature(state, {thermalPower, coolingName, timePeriodS, ambientTemp}) {
    const [R, C] = this.getThermalProperties(state, coolingName);
    return ambientTemp + thermalPower * R * (1.0 - Math.exp(-timePeriodS / (R * C)));
  }

  name() {
    return this.props['name'];
  }

  displayName() {
    return this.props['name'];
  }

  productInfo() {
    return this.props?.productInfo;
  }
}

class MoteusController extends Controller {
  constructor(props, power, thermal) {
    super(props, power, thermal);
  }

  getDefaultPwm() {
    return this.props['defaultPwm'];
  }

  getMaxPower(state, voltage, pwm) {
    const [P_l_W, V_l, P_h_W, V_h] = [
      this.props.P_l_W, this.props.V_l,
      this.props.P_h_W, this.props.V_h,
    ];
    const basePower = (() => {
      if (voltage <= V_l) return P_l_W;
      if (voltage >= V_h) return P_h_W;
      return (voltage - V_l) / (V_h - V_l) * (P_h_W - P_l_W) + P_l_W;
    })();
    const pwmDerate = pwm / 30000;
    return basePower * pwmDerate;
  }

  getSpeedFactor() {
    // Measured with moteus-c1, moteus-n1 and moteus-x1 on a MAD 8318 at 12V
    // and 18V on 2025-04-17.
    return 0.75;
  }

  getMaxCurrent() {
    return this.props['maxCurrent'];
  }
}

class OdriveController extends Controller {
  constructor(props, power, thermal) {
    super(props, power, thermal);
  }

  getDefaultPwm() {
    return 24000.0;
  }

  getMaxPower(state) {
    return this.props['P_W'];
  }

  getMaxCurrent(state, voltage) {
    if (voltage < this.props['maxCurrentDerateVoltage']) {
      return this.props['maxCurrent'];
    } else {
      return this.props['maxCurrent'] + (this.props['derateCurrent'] - this.props['maxCurrent']) *
          (voltage - this.props['maxCurrentDerateVoltage']) /
          (this.props['maxVoltage'] - this.props['maxCurrentDerateVoltage']);
    }
  }
}

class Motor {
  constructor({name, displayName, maxTemp, Kv, R, L, thermal,
               rotationCurrentCutoff=1000,
               rotationCurrentScale=1,
               rotationTorqueScale=1,
               d0, d1,
               productInfo=null}) {
    this.nameValue = name;
    this.displayNameValue = displayName;
    this.productInfoValue = productInfo;
    this.maxTemp = maxTemp;
    this.Kv = Kv;
    this.R = R;
    this.L = L;
    this.thermal = thermal;
    this.rotationCurrentScale = rotationCurrentScale;
    this.rotationCurrentCutoff = rotationCurrentCutoff;
    this.rotationTorqueScale = rotationTorqueScale;
    this.d0 = d0;
    this.d1 = d1;

    this.kt = 8.3 / this.Kv;
  }

  getThermalProperties(state, coolingName) {
    if (this.thermal?.[coolingName] == null) {
      return [null, null];
    }
    return [this.thermal[coolingName]['R'], this.thermal[coolingName]['C']];
  }

  getMaxTemp() {
    return this.maxTemp;
  }

  getKv() {
    return this.Kv;
  }

  name() {
    return this.nameValue;
  }

  displayName() {
    return this.displayNameValue;
  }

  productInfo() {
    return this.productInfoValue;
  }

  getBackEmf(velocityHz) {
    return velocityHz * 60 / this.getKv();
  }

  getPower(current, velocityHz) {
    const torque = current < this.rotationCurrentCutoff ?
      (this.kt * current) :
      (this.kt * this.rotationCurrentCutoff +
       this.rotationTorqueScale * Math.log2(
          1 + (current - this.rotationCurrentCutoff) * this.rotationCurrentScale));
    const Pmech = 2 * Math.PI * torque * velocityHz;
    const Pcopper = 1.5 * current * current * this.R;
    const ironDrag = this.d0 + this.d1 * velocityHz;
    const Piron = velocityHz == 0 ? 0 : (2 * Math.PI * velocityHz * ironDrag);
    return {
      torque: torque,
      Pmech: Pmech,
      Pcopper: Pcopper,
      Piron: Piron,
      Ptotal: Pmech + Pcopper + Piron,
    };
  }

  getCurrentFromThermalPowerAndVelocity(state, thermalW, velocityHz, maxControllerPower, supplyVoltageMargin) {
    // TODO: Should we model the fact that resistance tends to go up with
    // temperature?

    // Our convention is that resistance is measured to the virtual center,
    // and that phase current is measured as per moteus convention.  Thus:
    //
    // torque = Kt * I + ts * log2(1 + (I - Ic)*is)
    // Pmech = 2 * pi * torque * velocityHz
    // Pcopper = 1.5 * I^2 * R
    // Ptotal = Pcopper + Piron + Pmech

    // and (Pcopper + Piron) < thermalW
    // and (Ptotal) < maxControllerPower

    const ImaxPossible = Math.min(supplyVoltageMargin / this.R,
      Math.sqrt(Math.min(thermalW, maxControllerPower) / 1.5 / this.R));
    // This equation is not really possible to solve directly, so lets just
    // find it numerically.  The answer is much easier if the velocity is 0.
    if (velocityHz == 0.0) {
      return ImaxPossible;
    }

    // Bisect between 0 and ImaxPossible to find a current which is as large
    // as possible while satisfying both of our inequalities.
    const valid = (I) => {
      const r = this.getPower(I, velocityHz);
      return (((r.Pcopper + r.Piron) < thermalW) &&
              (r.Ptotal < maxControllerPower));
    };

    return bisectMaxTrue(ImaxPossible, valid, 0.01);
  }

  getTorqueFromCurrent(state, currentA) {
    if (currentA < this.rotationCurrentCutoff) {
      return currentA * this.kt;
    }
    return (this.rotationCurrentCutoff * this.kt +
            this.rotationTorqueScale *
            (Math.log2(Math.max(1.0 + (currentA - this.rotationCurrentCutoff) *
            this.rotationCurrentScale, 0.00001))));
  }

  getMaxVelocityHz(state, controllerInstance, controllerState, voltage, voltageState) {
    return controllerInstance.getSpeedFactor(controllerState) * voltage.getVoltage(voltageState) * this.Kv / 60.0;
  }

  // Note: getOperatingPoint method omitted as it depends on OperatingPoint class
}

class MoteusC1 extends MoteusController {
  constructor() {
    super({
      name: 'moteus-c1',
      maxTemp: 60.0,
      maxCurrent: 20.0,
      maxVoltage: 51.0,
      P_l_W: 250.0,
      V_l: 28.0,
      P_h_W: 150.0,
      V_h: 41.0,
      defaultPwm: 30000,
      productInfo: '[product page]',
    },
    {
      'voltages' : [12, 24, 36, 48],
      'pwms' : [15000, 30000, 40000, 60000],
      'k0' : [[.612, .906, 1.161, 1.378],
              [.727, .986, 1.161, 1.515],
              [.677, .988, 1.256, 1.576],
              [.718, 1.034, 1.367, 1.710]],
      'k1' : [[0.000, 0.017, 0.043, 0.112],
              [0.009, 0.107, 0.224, 0.248],
              [0.073, 0.176, 0.281, 0.360],
              [0.155, 0.330, 0.468, 0.544]],
      'k2' : [[0.046, 0.049, 0.051, 0.046],
              [0.051, 0.051, 0.048, 0.050],
              [0.051, 0.053, 0.055, 0.049],
              [0.052, 0.054, 0.053, 0.056]],
    },
    {
      'none' :         {R: 11.3, C:10.7},
      'heatspreader' : {R: 11.2, C:10.7},
      '5vfan' :        {R: 2.55, C:10.7},
      'max' :          {R: 2.55, C:10.7},
    });
  }
}

class MoteusR4 extends MoteusController {
  constructor() {
    super({
      name: 'moteus-r4',
      maxTemp: 60.0,
      maxCurrent: 100.0,
      maxVoltage: 42.0,
      P_l_W: 900.0,
      V_l: 30.0,
      P_h_W: 400.0,
      V_h: 38.0,
      defaultPwm: 30000,
      productInfo: '[product page]',
    },
    {
      'voltages' : [12, 24, 36, 42],
      'pwms' : [15000, 30000, 40000, 60000],
      'k0' : [[0.514, 0.938, 1.266, 1.427],
              [0.792, 1.167, 1.593, 1.834],
              [0.851, 1.392, 1.765, 2.064],
              [0.974, 1.504, 2.098, 2.524]],
      'k1' : [[0.022, 0.007, 0.015, 0.018],
              [0.021, 0.035, 0.045, 0.050],
              [0.030, 0.020, 0.092, 0.091],
              [0.046, 0.110, 0.139, 0.142]],
      'k2' : [[0.010, 0.011, 0.011, 0.011],
              [0.011, 0.012, 0.013, 0.013],
              [0.011, 0.014, 0.012, 0.013],
              [0.013, 0.013, 0.015, 0.018]],
    },
    {
      'none' :         {R: 10.0, C:12.7},
      '5vfan' :        {R: 3.7,  C:12.7},
      'heatspreader':  {R: 8.6,  C:13.9},
      'heatspreader_4030sink': {R:6.2, C:19.4},
      'max':           {R: 2.4,  C:12.7},
    });
  }
}

/* ---------- Reusable ConfigFieldSelector Component ---------- */
function ConfigFieldSelector({
  selected,
  onSelectedChange,
  disabled = false,
  placeholder = "Select or create fields..."
}) {
  const [inputValue, setInputValue] = useState('');

  /* utility – already have this field? */
  const fieldTaken = (f) => selected.some((s) => s.field === f);

  /* Generate dynamic options based on current input */
  const getCurrentOptions = () => {
    const kv = parseKV(inputValue);
    const baseFields = getBaseFields(selected);

    // If no '=' found, show base fields
    if (!kv || kv.data === undefined) {
      return baseFields;
    }

    // If field has constrained values, show all or filtered options
    const fieldOptions = fieldValueOptions[kv.field];
    if (fieldOptions) {
      // Show all options if data is empty (just typed '='), otherwise filter
      const filteredOptions = kv.data === '' ? fieldOptions :
        fieldOptions.filter(value => value.toLowerCase().includes(kv.data.toLowerCase()));

      return filteredOptions.map(value => ({
        field: kv.field,
        value: kv.field,
        data: value,
        label: `${kv.field}=${value}`
      }));
    }

    // For unconstrained fields, return base fields
    return baseFields;
  };

  /* --- callbacks passed to <Creatable> --- */
  const getNewOptionData = (input) =>
    parseKV(input) ?? { field: input, value: input, label: input };

  const isValidNewOption = (input) => {
    const kv = parseKV(input);
    if (!kv) return false;

    // Check if the field is in our allowed list
    const baseFields = getBaseFields(selected);
    const isValidField = baseFields.some(bf => bf.field === kv.field);

    return isValidField && !fieldTaken(kv.field);         // allow only if valid field and unique
  };

  const isOptionDisabled = (opt) => fieldTaken(opt.field);

  /* crucial: actually add the newly-typed chip */
  const onCreateOption = (input) => {
    const kv = parseKV(input);
    if (!kv || fieldTaken(kv.field)) return;    // guard
    onSelectedChange([...selected, kv]);
    setInputValue('');
  };

  const handleInputChange = (input, { action }) => {
    if (action === 'input-change') {
      setInputValue(input);
    }
    return input;
  };

  const handleChange = (newValue) => {
    onSelectedChange(newValue);
    setInputValue(''); // Clear input after selection
  };

  return html`
    <${Creatable}
        isMulti
        isDisabled=${disabled}
        value=${selected}
        onChange=${handleChange}
        placeholder=${placeholder}
        options=${getCurrentOptions()}
        getNewOptionData=${getNewOptionData}
        isValidNewOption=${isValidNewOption}
        onCreateOption=${onCreateOption}
        isOptionDisabled=${isOptionDisabled}
        formatCreateLabel=${(v) => `add ${v}`}
        onInputChange=${handleInputChange}
        inputValue=${inputValue}
      />
  `;
}

/* ---------- Panel Components ---------- */
function CommonConfigPanel({ selected, onSelectedChange }) {
  return html`
    <div class="panelContainer">
      <div class="panelTitle">Common Config</div>
      <div class="panelContent">
        <${ConfigFieldSelector}
          selected=${selected}
          onSelectedChange=${onSelectedChange}
          placeholder="Add common configuration..."
        />
      </div>
    </div>
  `;
}

function AxisPanel({ axisNumber, configs, onConfigsChange }) {
  const handleConfigChange = (index, newValue) => {
    let newConfigs = [...configs];
    newConfigs[index] = newValue;

    // If this is the last (empty) field and user added something, add a new empty field
    if (index === configs.length - 1 && newValue.length > 0) {
      newConfigs.push([]);
    }

    // Remove empty fields that are not the last one
    newConfigs = newConfigs.filter((config, i) => {
      // Keep the last field (even if empty) and any non-empty fields
      return i === newConfigs.length - 1 || config.length > 0;
    });

    // Ensure we always have at least one field (empty if needed)
    if (newConfigs.length === 0) {
      newConfigs = [[]];
    }

    onConfigsChange(newConfigs);
  };

  return html`
    <div class="panelContainer">
      <div class="panelTitle">Axis ${axisNumber}</div>
      <div class="panelContent">
        ${configs.map((config, index) => html`
          <div key=${index} class="configField">
            <${ConfigFieldSelector}
              selected=${config}
              onSelectedChange=${(newValue) => handleConfigChange(index, newValue)}
              placeholder=${index === configs.length - 1 ? `Add new axis ${axisNumber} configuration...` : `Axis ${axisNumber} configuration...`}
            />
          </div>
        `)}
      </div>
    </div>
  `;
}

/* ---------- Model Registry ---------- */
const modelRegistry = {
  controller: {
    'moteus-c1': new MoteusC1(),
    'moteus-r4': new MoteusR4(),
    // Add more controllers as they're migrated
  },
  motor: {
    // Add motor instances when needed
  }
};

/* ---------- Simulator Component ---------- */
function Simulator({ commonConfig, axisConfigs }) {
  // Convert chip array to key-value dictionary
  const convertChipsToDict = (chips) => {
    const dict = {};
    chips.forEach(chip => {
      if (chip.field) {
        dict[chip.field] = chip.data !== undefined ? chip.data : null;
      }
    });
    return dict;
  };

  // Convert string values to model instances where applicable
  const reifyObjects = (dict) => {
    const reified = {};
    Object.entries(dict).forEach(([key, value]) => {
      if (value === null) {
        reified[key] = null;
      } else if (modelRegistry[key] && modelRegistry[key][value]) {
        reified[key] = modelRegistry[key][value];
      } else {
        reified[key] = value; // Keep as string if no model found
      }
    });
    return reified;
  };

  // Restructure configuration data
  const restructureConfig = () => {
    // Convert common config
    const commonDict = convertChipsToDict(commonConfig);
    const commonReified = reifyObjects(commonDict);
    
    // Convert each axis config
    const axisData = axisConfigs.map((axisConfigs, axisIndex) => {
      // Each axis can have multiple configuration lines
      const axisLines = axisConfigs.map(lineChips => {
        const dict = convertChipsToDict(lineChips);
        return reifyObjects(dict);
      }).filter(dict => Object.keys(dict).length > 0); // Remove empty dictionaries
      
      return {
        axisNumber: axisIndex + 1,
        configurations: axisLines
      };
    }).filter(axis => axis.configurations.length > 0); // Remove empty axes

    return {
      common: commonReified,
      axes: axisData
    };
  };

  const restructuredConfig = restructureConfig();

  return html`
    <div>
      <p>Simulator component</p>
      <pre>${JSON.stringify(restructuredConfig, null, 2)}</pre>
    </div>
  `;
}

/* ---------- Main App Component ---------- */
function App() {
  const [commonConfig, setCommonConfig] = useState(
    Object.entries(defaultCommonValues).map(([field, value]) => ({
      field,
      value: field,
      data: value,
      label: `${field}=${value}`
    }))
  );
  const [axisConfigs, setAxisConfigs] = useState([[[]]]);  // Start with one axis with one empty config

  const handleAxisConfigChange = (axisIndex, newConfigs) => {
    let newAxisConfigs = [...axisConfigs];
    newAxisConfigs[axisIndex] = newConfigs;

    // If this is the last axis and it has any content, add a new empty axis
    if (axisIndex === axisConfigs.length - 1 && hasAnyContent(newConfigs)) {
      newAxisConfigs.push([[]]);  // Add new axis with one empty config
    }

    // Remove empty axes that are not the last one
    newAxisConfigs = newAxisConfigs.filter((configs, i) => {
      // Keep the last axis (even if empty) and any non-empty axes
      return i === newAxisConfigs.length - 1 || hasAnyContent(configs);
    });

    // Ensure we always have at least one axis (empty if needed)
    if (newAxisConfigs.length === 0) {
      newAxisConfigs = [[[]]];  // One axis with one empty config
    }

    setAxisConfigs(newAxisConfigs);
  };

  // Helper function to check if any config in an axis has content
  const hasAnyContent = (configs) => {
    return configs.some(config => config.length > 0);
  };

  /* optional: watch state while testing */
  useEffect(() => {
    console.log('Common Config:', commonConfig);
    console.log('Axis Configs:', axisConfigs);
  }, [commonConfig, axisConfigs]);

  return html`
    <div class="pageContainer">
      <div class="panelColumn">
        <${CommonConfigPanel}
          selected=${commonConfig}
          onSelectedChange=${setCommonConfig}
        />
        ${axisConfigs.map((configs, axisIndex) => html`
          <${AxisPanel}
            key=${axisIndex}
            axisNumber=${axisIndex + 1}
            configs=${configs}
            onConfigsChange=${(newConfigs) => handleAxisConfigChange(axisIndex, newConfigs)}
          />
        `)}
      </div>
      <div class="resultsColumn">
        <${Simulator} 
          commonConfig=${commonConfig} 
          axisConfigs=${axisConfigs}
        />
      </div>
    </div>
  `;
}

render(html`<${App} />`, document.body);
  </script>
</head>

<body>
<footer>
  <div>
    moteus Performance Analysis Tool
    | Licensed under Apache 2.0
    | (c) 2025 mjbots Robotic Systems
    | <a href="https://mjbots.com">https://mjbots.com</a>
  </div>
</footer>
</body>

</html>
