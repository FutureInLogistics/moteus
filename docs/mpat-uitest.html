<!DOCTYPE html>
<html>

<head>
  <title>moteus Perfomance Analysis Tool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-size: 14px;
      font-family: system-ui, sans-serif;
      color: #333;
      background: #fcfcfc;
      margin: 0;
      padding: 1 rem;
      padding-bottom: 2.5em;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      table-layout: auto;
    }
    td, th {
      border: none;
      padding: 0.3rem;
      text-align: left;
    }
    th {
      font-weight: 600;
    }
    td {
      border-top: 1px solid #eee;
    }
    td:nth-child(odd) {
      background-color:#f9fafb;
    }

    td:nth-child(even) {
      background-color: #ffffff;
    }

    th:nth-child(odd) {
      background-color: #f1f5f9;
    }
    th:nth-child(even) {
      background-color: #f5f9fa;
    }

    footer {
      position: fixed;
      bottom: 0;
      width: 100%;
      background: #f1f1f1;
      padding: 10px;
      text-align: center;
      font-size: 0.9em;
      border-top: 1px solid #ccc;
    }

    .pageContainer {
      display: flex;
      flex-wrap: wrap;
      gap: 0.2rem;
    }

    .panelColumn {
      flex: 1 1 300px;
      max-width: 400px;
      min-width: 200px;
      padding: 1em;
    }

    .resultsColumn {
      flex: 2 1 500px;
      min-width: 200px;
      padding: 1em;
    }

    .panelContainer {
      border: 1px solid #ddd;
      border-radius: 3px;
      margin: 0.4em 0;
      background: white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
      /*overflow: hidden;*/
    }

    .panelContent {
      padding: 1rem;
    }

    .configField {
      margin-bottom: 0.75rem;
    }

    .configField:last-child {
      margin-bottom: 0;
    }

    .panelTitle {
      cursor: pointer;
      padding: 0.5rem;
      background:#f7f9fc;
      font-weight: 600;
      border-bottom: 1px solid #eee;
    }

    .resultTable {
      display: inline-block;
      max-width: 100%;
      margin: 1 rem auto;
      background: white;
      border-radius: 5px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
    }

    .multiHeader {
      font-weight: 600;
    }

    .overlayContainer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.0);
      z-index: 1000;
      outline: 1px dashed red;
      pointer-events: none;
    }

    .overlayBody {
      position: fixed;
      top: 0;
      right: 0;
      width: 300px;
      height: 100%;
      background: white;
      borderLeft: 1px solid #ccc;
      padding: 1rem;
      box-shadow: -2px 0px 8px rgba(0, 0, 0, 0.2);
      pointer-events: auto;
    }

    @media (max-width: 600px) {
      .overlayBody {
        left: 5px;
        right: 5px;
        top: 5px;
        bottom: 5px;
        border-left: none;
        box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.2);
      }
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "preact":                 "https://esm.sh/preact@10.26.5",
      "preact/":                "https://esm.sh/preact@10.26.5/",
      "preact/hooks":           "https://esm.sh/preact@10.26.5/hooks",
      "preact/compat":          "https://esm.sh/preact@10.26.5/compat",
      "preact/jsx-runtime":     "https://esm.sh/preact@10.26.5/jsx-runtime",

      "react": "https://esm.sh/preact@10.26.5/compat",
	  "react/": "https://esm.sh/preact@10.26.5/compat/",
	  "react-dom": "https://esm.sh/preact@10.26.5/compat",
      "react-dom/":           "https://esm.sh/preact@10.26.5/compat/",
      "react/jsx-runtime":    "https://esm.sh/preact@10.26.5/jsx-runtime",
      "react/jsx-dev-runtime":"https://esm.sh/preact@10.26.5/jsx-runtime",
      "react-dom/client":     "https://esm.sh/preact@10.26.5/compat",

      "htm": "https://esm.sh/htm@3.1.1",
      "react-select": "https://esm.sh/react-select@5?alias=react:preact/compat,react-dom:preact/compat&deps=preact@10.26.5",
      "react-select/creatable": "https://esm.sh/react-select@5/creatable?alias=react:preact/compat,react-dom:preact/compat&deps=preact@10.26.5"

    }
  }
</script>
  <script>
    // Embed the contents of preact, preact-hooks, and htm.
    // preact 10.26.5 - MIT License: https://github.com/preactjs/preact/blob/main/LICENSE
    // htm 3.1.1 - Apache 2.0 License: https://github.com/developit/htm/blob/master/LICENSE
    //
    // These were generated by:
    //  curl -L https://unpkg.com/preact@10.26.5/dist/preact.umd.js -o preact.umd.js
    //  curl -L https://unpkg.com/preact@10.26.5/hooks/dist/hooks.umd.js -o preact-hooks.umd.js
    //  curl -L https://unpkg.com/htm@3.1.1/dist/htm.umd.js -o htm.umd.js
  </script>
  <script type="module">
    // Copyright 2025 mjbots Robotic Systems, LLC.  info@mjbots.com
    //
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    //
    //     http://www.apache.org/licenses/LICENSE-2.0
    //
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.

    import {h, render } from "preact";
    import { useState, useEffect } from "preact/hooks";
    import htm from "htm";
    import Creatable from "react-select/creatable";

    const html = htm.bind(h);

/* ---------- helpers ---------- */
const parseKV = (txt) => {
  const [field, val] = txt.split('=');
  if (!field) return null;  // must have at least a field name
  if (val === undefined) {
    // No '=' found, treat as simple field
    return { field, value: field, label: field };
  }
  // '=' found (val could be empty string)
  return { field, value: field, data: val, label: `${field}=${val}` };
};

// Default values for common config - this defines all available fields
const defaultCommonValues = {
  'controller': 'moteus-x1',
  'controller_cooling': 'none',
  'motor': 'mad8318',
  'motor_cooling': 'none',
  'voltage': '24',
  'velocity': '0',
  'pwm': 'default',
  'supply_power': 'infinity',
  'supply_current': 'infinity',
  'time': 'infinity',
  'gear_ratio': '1',
  'ambient_temp': '25',
  'max_controller_temp': 'default',
  'max_motor_temp': 'default',
  'torque': '0',
  'output': 'phase_current',
  'analysis': "max_current", // 'max_speed', 'operating_point'
};

// Default values for motor sub-fields
const motorSubFieldDefaults = {
  'motor.kv': '100',
  'motor.r': '0.1',
  'motor.l': '1e-6',
  'motor.mass': '0.1',
  'motor.diameter': '30',
  'motor.type': 'outrunner'
};

/* Field-specific value suggestions - only for constrained fields */
const fieldValueOptions = {
  'controller': [
    'moteus-c1',
    'moteus-r4',
    'moteus-n1',
    'moteus-x1',
    'odrive-micro',
    'odrive-s1',
    'odrive-pro',
  ],
  'controller_cooling': [
    'none',
    'heatspreader',
    '4030sink',
    'fan_5v',
    'fan_12v',
    'max',
  ],
  'motor': [
    'mad8318',
    'mj5208',
    'gbm5208',
    'be8108',
    'hoverboard350',
    'ht1105',
    'model',
    'extrapolated',
  ],
  'motor_cooling': [
    'none',
    'max',
  ],
  'analysis': [
    'max_current',
    'max_torque',
    'max_speed',
    'operating_point',
  ],
  'output': [
    'torque',
    'speed',
    'controller_temp',
    'motor_temp',
    'supply_power',
    'supply_current',
    'phase_current',
    'copper_loss',
    'iron_loss',
    'controller_loss',
    'mechanical_power',
    'efficiency',
  ],
  'motor.type': [
    'outrunner',
    'inrunner'
  ]
};

/* Motor model sub-field configurations */
const motorModelFields = {
  'model': ['kv', 'r', 'l', 'mass'],
  'extrapolated': ['kv', 'mass', 'diameter', 'type']
};

/* Generate dynamic sub-fields based on selected values */
const generateDynamicFields = (selectedValues) => {
  const dynamicFields = [];

  selectedValues.forEach(selected => {
    if (selected.field === 'motor' && selected.data) {
      const subFields = motorModelFields[selected.data];
      if (subFields) {
        subFields.forEach(subField => {
          const fullFieldName = `motor.${subField}`;
          dynamicFields.push({
            field: fullFieldName,
            value: fullFieldName,
            label: fullFieldName
          });
        });
      }
    }
  });

  return dynamicFields;
};

/* shared base fields for all selectors - derived from default values */
const getBaseFields = (selectedValues) => {
  const staticFields = Object.keys(defaultCommonValues).map(name => ({
    field: name,
    value: name,
    label: name
  }));

  const dynamicFields = generateDynamicFields(selectedValues);

  return [...staticFields, ...dynamicFields];
};

/* ---------- Model Classes ---------- */

function bisectMaxTrue(M, metric, threshold) {
  let lo = 0;
  let hi = M;

  if (!metric(0)) {
    return null;
  }

  if (metric(M)) {
    return M;
  }

  // Invariant: metric(lo) === true, metric(hi) === false, lo < hi
  while (lo < (hi - threshold)) {
    const mid = 0.5 * (lo + hi);
    if (metric(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }

  return lo;
}

class Interpolator2D {
  constructor(xlabels, ylabels, data) {
    this.xlabels = xlabels;
    this.ylabels = ylabels;
    this.data = data;

    // Validate that our data has the right number of rows and columns.
    if (data.length != this.ylabels.length) {
      throw new Error("Data matrix does not match label row count");
    }
    data.map((row) => {
      if (row.length != this.xlabels.length) {
        throw new Error("Data matrix does not match label column count");
      }
    });
  }

  // Also from 4o:
  //
  // Return a linear interpolation between nearest points, or if the
  // requested point is outside the allowed bounds, just extend the
  // nearest edge or corner indefinitely.
  interpolate(x, y) {
    // Helper function: Given a sorted label array and a value, returns
    // the lower and upper indices and the interpolation factor.
    function getInterval(labels, value) {
      const n = labels.length;
      if (value <= labels[0]) {
        return { indexLow: 0, indexHigh: 0, t: 0 };
      }
      if (value >= labels[n - 1]) {
        return { indexLow: n - 1, indexHigh: n - 1, t: 0 };
      }
      // Find the interval where labels[i] <= value <= labels[i+1]
      for (let i = 0; i < n - 1; i++) {
        if (value >= labels[i] && value <= labels[i + 1]) {
          let t = (value - labels[i]) / (labels[i + 1] - labels[i]);
          return { indexLow: i, indexHigh: i + 1, t: t };
        }
      }
      // Fallback (should never be reached)
      return { indexLow: n - 1, indexHigh: n - 1, t: 0 };
    }

    // Get the intervals and interpolation factors for x and y.
    const xInterval = getInterval(this.xlabels, x);
    const yInterval = getInterval(this.ylabels, y);

    const i0 = xInterval.indexLow;
    const i1 = xInterval.indexHigh;
    const t = xInterval.t;

    const j0 = yInterval.indexLow;
    const j1 = yInterval.indexHigh;
    const u = yInterval.t;

    // Retrieve the four surrounding grid values.
    const v00 = this.data[j0][i0];
    const v01 = this.data[j0][i1];
    const v10 = this.data[j1][i0];
    const v11 = this.data[j1][i1];

    // Interpolate along x for the two rows.
    const interpX0 = (1 - t) * v00 + t * v01;
    const interpX1 = (1 - t) * v10 + t * v11;

    // Interpolate the two results along y.
    return (1 - u) * interpX0 + u * interpX1;
  }
}

    class OperatingPoint {
      torque = null;
      speed = null;
      controller_temp = null;
      motor_temp = null;
      supply_power = null;
      supply_current = null;
      phase_current = null;
      copper_loss = null;
      iron_loss = null;
      controller_loss = null;
      mechanical_power = null;
      efficiency = null;

      constructor(opts = {}) {
        Object.assign(this, opts);
      }

      render() {
        return html`
        <h3>Operating Point</h3>
        <table>
          ${[['torque', 'Motor Torque (Nm)'],
             ['speed', 'Speed (Hz)'],
             ['controller_temp', 'Controller Temperature (°C)'],
             ['motor_temp', 'Motor Temperature (°C)'],
             ['supply_power', 'Supply Power (W)'],
             ['supply_current', 'Supply Current (A)'],
             ['phase_current', 'Phase Current (A)'],
             ['copper_loss', 'Copper Loss (W)'],
             ['iron_loss', 'Iron Loss (W)'],
             ['controller_loss', 'Controller Loss (W)'],
             ['mechanical_power', 'Mechanical Power (W)'],
             ['efficiency', 'Efficiency (%)'],
           ].map(([attrName, displayName]) =>
           html`${this[attrName] !== null && this[attrName] !== undefined ? html`<tr><td>${displayName}</td><td>${this[attrName].toFixed(3)}</td></tr>` : ''}`)
           }
        </table>
        `
      }
    }

class Controller {
  constructor(props, power, thermal) {
    this.props = props;
    this.power = power;
    this.thermal = thermal;
    this.k0 = new Interpolator2D(this.power.voltages, this.power.pwms, this.power.k0);
    this.k1 = new Interpolator2D(this.power.voltages, this.power.pwms, this.power.k1);
    this.k2 = new Interpolator2D(this.power.voltages, this.power.pwms, this.power.k2);
  }

  getThermalProperties(coolingName) {
    if (this.thermal?.[coolingName] == null) {
      return [null, null];
    }
    return [this.thermal[coolingName]['R'], this.thermal[coolingName]['C']];
  }

  getMaxTemp() {
    return this.props['maxTemp'];
  }

  getMaxVoltage() {
    return this.props['maxVoltage'];
  }

  getMaxSpeed(voltage, motor) {
    return voltage * motor.getKv() * this.getSpeedFactor() / 60.0;
  }

  getCurrentFromThermalPower(thermalW, {voltage, pwm}) {
    const [k0,k1,k2] = [
      this.k0.interpolate(voltage, pwm),
      this.k1.interpolate(voltage, pwm),
      this.k2.interpolate(voltage, pwm),
    ];
    const c = k0;
    const b = k1;
    const a = k2;

    return Math.min(this.getMaxCurrent(voltage),
      (-b + Math.sqrt(Math.max(0, b * b - 4 * a * (c - thermalW)))) / (2 * a));
  }

  getThermalPower({voltage, pwm, current}) {
    const [k0, k1, k2] = [
      this.k0.interpolate(voltage, pwm),
      this.k1.interpolate(voltage, pwm),
      this.k2.interpolate(voltage, pwm),
    ];

    const thermalPower = k0 + k1 * current + k2 * current * current;
    return thermalPower;
  }

  getTemperature(thermalPower, {controller_cooling, time, ambient_temp}) {
    const timePeriodS = time;
    const [R, C] = this.getThermalProperties(controller_cooling);
    return ambient_temp + thermalPower * R * (1.0 - Math.exp(-timePeriodS / (R * C)));
  }

  productInfo() {
    return this.props?.productInfo;
  }
}

class MoteusController extends Controller {
  constructor(props, power, thermal) {
    super(props, power, thermal);
  }

  getDefaultPwm() {
    return this.props['defaultPwm'];
  }

  getMaxPower(voltage, pwm) {
    const [P_l_W, V_l, P_h_W, V_h] = [
      this.props.P_l_W, this.props.V_l,
      this.props.P_h_W, this.props.V_h,
    ];
    const basePower = (() => {
      if (voltage <= V_l) return P_l_W;
      if (voltage >= V_h) return P_h_W;
      return (voltage - V_l) / (V_h - V_l) * (P_h_W - P_l_W) + P_l_W;
    })();
    const pwmDerate = pwm / 30000;
    return basePower * pwmDerate;
  }

  getSpeedFactor() {
    // Measured with moteus-c1, moteus-n1 and moteus-x1 on a MAD 8318 at 12V
    // and 18V on 2025-04-17.
    return 0.75;
  }

  getMaxCurrent() {
    return this.props['maxCurrent'];
  }
}

class OdriveController extends Controller {
  constructor(props, power, thermal) {
    super(props, power, thermal);
  }

  getDefaultPwm() {
    return 24000.0;
  }

  getMaxPower() {
    return this.props['P_W'];
  }

  getMaxCurrent(voltage) {
    if (voltage < this.props['maxCurrentDerateVoltage']) {
      return this.props['maxCurrent'];
    } else {
      return this.props['maxCurrent'] + (this.props['derateCurrent'] - this.props['maxCurrent']) *
          (voltage - this.props['maxCurrentDerateVoltage']) /
          (this.props['maxVoltage'] - this.props['maxCurrentDerateVoltage']);
    }
  }
}

class Motor {
  constructor({name, displayName, maxTemp, Kv, R, L, thermal,
               rotationCurrentCutoff=1000,
               rotationCurrentScale=1,
               rotationTorqueScale=1,
               d0, d1,
               productInfo=null}) {
    this.nameValue = name;
    this.displayNameValue = displayName;
    this.productInfoValue = productInfo;
    this.maxTemp = maxTemp;
    this.Kv = Kv;
    this.R = R;
    this.L = L;
    this.thermal = thermal;
    this.rotationCurrentScale = rotationCurrentScale;
    this.rotationCurrentCutoff = rotationCurrentCutoff;
    this.rotationTorqueScale = rotationTorqueScale;
    this.d0 = d0;
    this.d1 = d1;

    this.kt = 8.3 / this.Kv;
  }

  getThermalProperties(coolingName) {
    if (this.thermal?.[coolingName] == null) {
      return [null, null];
    }
    return [this.thermal[coolingName]['R'], this.thermal[coolingName]['C']];
  }

  getMaxTemp() {
    return this.maxTemp;
  }

  getKv() {
    return this.Kv;
  }

  name() {
    return this.nameValue;
  }

  displayName() {
    return this.displayNameValue;
  }

  productInfo() {
    return this.productInfoValue;
  }

  getBackEmf(velocityHz) {
    return velocityHz * 60 / this.getKv();
  }

  getPower(current, velocityHz) {
    const torque = current < this.rotationCurrentCutoff ?
      (this.kt * current) :
      (this.kt * this.rotationCurrentCutoff +
       this.rotationTorqueScale * Math.log2(
          1 + (current - this.rotationCurrentCutoff) * this.rotationCurrentScale));
    const Pmech = 2 * Math.PI * torque * velocityHz;
    const Pcopper = 1.5 * current * current * this.R;
    const ironDrag = this.d0 + this.d1 * velocityHz;
    const Piron = velocityHz == 0 ? 0 : (2 * Math.PI * velocityHz * ironDrag);
    return {
      torque: torque,
      Pmech: Pmech,
      Pcopper: Pcopper,
      Piron: Piron,
      Ptotal: Pmech + Pcopper + Piron,
    };
  }

  getCurrentFromThermalPowerAndVelocity(thermalW, velocityHz, maxControllerPower, supplyVoltageMargin) {
    // TODO: Should we model the fact that resistance tends to go up with
    // temperature?

    // Our convention is that resistance is measured to the virtual center,
    // and that phase current is measured as per moteus convention.  Thus:
    //
    // torque = Kt * I + ts * log2(1 + (I - Ic)*is)
    // Pmech = 2 * pi * torque * velocityHz
    // Pcopper = 1.5 * I^2 * R
    // Ptotal = Pcopper + Piron + Pmech

    // and (Pcopper + Piron) < thermalW
    // and (Ptotal) < maxControllerPower

    const ImaxPossible = Math.min(supplyVoltageMargin / this.R,
      Math.sqrt(Math.min(thermalW, maxControllerPower) / 1.5 / this.R));
    // This equation is not really possible to solve directly, so lets just
    // find it numerically.  The answer is much easier if the velocity is 0.
    if (velocityHz == 0.0) {
      return ImaxPossible;
    }

    // Bisect between 0 and ImaxPossible to find a current which is as large
    // as possible while satisfying both of our inequalities.
    const valid = (I) => {
      const r = this.getPower(I, velocityHz);
      return (((r.Pcopper + r.Piron) < thermalW) &&
              (r.Ptotal < maxControllerPower));
    };

    return bisectMaxTrue(ImaxPossible, valid, 0.01);
  }

  getTorqueFromCurrent(currentA) {
    if (currentA < this.rotationCurrentCutoff) {
      return currentA * this.kt;
    }
    return (this.rotationCurrentCutoff * this.kt +
            this.rotationTorqueScale *
            (Math.log2(Math.max(1.0 + (currentA - this.rotationCurrentCutoff) *
            this.rotationCurrentScale, 0.00001))));
  }

  getMaxVelocityHz(controller, voltage) {
    return controller.getSpeedFactor() * voltage * this.Kv / 60.0;
  }

  // Note: getOperatingPoint method omitted as it depends on OperatingPoint class
}

class MoteusC1 extends MoteusController {
  constructor() {
    super({
      name: 'moteus-c1',
      maxTemp: 60.0,
      maxCurrent: 20.0,
      maxVoltage: 51.0,
      P_l_W: 250.0,
      V_l: 28.0,
      P_h_W: 150.0,
      V_h: 41.0,
      defaultPwm: 30000,
      productInfo: '[product page]',
    },
    {
      'voltages' : [12, 24, 36, 48],
      'pwms' : [15000, 30000, 40000, 60000],
      'k0' : [[.612, .906, 1.161, 1.378],
              [.727, .986, 1.161, 1.515],
              [.677, .988, 1.256, 1.576],
              [.718, 1.034, 1.367, 1.710]],
      'k1' : [[0.000, 0.017, 0.043, 0.112],
              [0.009, 0.107, 0.224, 0.248],
              [0.073, 0.176, 0.281, 0.360],
              [0.155, 0.330, 0.468, 0.544]],
      'k2' : [[0.046, 0.049, 0.051, 0.046],
              [0.051, 0.051, 0.048, 0.050],
              [0.051, 0.053, 0.055, 0.049],
              [0.052, 0.054, 0.053, 0.056]],
    },
    {
      'none' :         {R: 11.3, C:10.7},
      'heatspreader' : {R: 11.2, C:10.7},
      '5vfan' :        {R: 2.55, C:10.7},
      'max' :          {R: 2.55, C:10.7},
    });
  }
}

class MoteusR4 extends MoteusController {
  constructor() {
    super({
      name: 'moteus-r4',
      maxTemp: 60.0,
      maxCurrent: 100.0,
      maxVoltage: 42.0,
      P_l_W: 900.0,
      V_l: 30.0,
      P_h_W: 400.0,
      V_h: 38.0,
      defaultPwm: 30000,
      productInfo: '[product page]',
    },
    {
      'voltages' : [12, 24, 36, 42],
      'pwms' : [15000, 30000, 40000, 60000],
      'k0' : [[0.514, 0.938, 1.266, 1.427],
              [0.792, 1.167, 1.593, 1.834],
              [0.851, 1.392, 1.765, 2.064],
              [0.974, 1.504, 2.098, 2.524]],
      'k1' : [[0.022, 0.007, 0.015, 0.018],
              [0.021, 0.035, 0.045, 0.050],
              [0.030, 0.020, 0.092, 0.091],
              [0.046, 0.110, 0.139, 0.142]],
      'k2' : [[0.010, 0.011, 0.011, 0.011],
              [0.011, 0.012, 0.013, 0.013],
              [0.011, 0.014, 0.012, 0.013],
              [0.013, 0.013, 0.015, 0.018]],
    },
    {
      'none' :         {R: 10.0, C:12.7},
      '5vfan' :        {R: 3.7,  C:12.7},
      'heatspreader':  {R: 8.6,  C:13.9},
      'heatspreader_4030sink': {R:6.2, C:19.4},
      'max':           {R: 2.4,  C:12.7},
    });
  }
}

class MJ5208 extends Motor {
  constructor() {
    super({
      name: 'mj5208',
      displayName: 'mj5208',
      maxTemp: 80,
      Kv: 304,
      R: 0.047,
      L: 28.6e-6,
      mass_kg: 0.192,
      rotationCurrentCutoff: 22.5,
      rotationCurrentScale: 0.02494,
      rotationTorqueScale: 0.6638,
      thermal: {
        'none': {R: 4.55, C: 164.59},  // measured 2025-04-18
        'max':  {R: 0.48, C: 164.59},  // measured 2025-04-18 w/ large desk fan
      },
      // The following iron loss model was generated from pypowertrain and is
      // not from any measured or design values.
      d0: 0.002784,
      d1: 5.6668e-5,
      productInfo: '[product page]',
    });
  }
}

class MAD8318 extends Motor {
  constructor() {
    super({
      name: 'mad8318',
      displayName: 'MAD 8318',
      maxTemp: 80,
      Kv: 120,
      R: 0.015,
      L: 9.75e-6,
      mass_kg: 0.646,
      rotationCurrentCutoff: 31.07,
      rotationCurrentScale: 0.004214,
      rotationTorqueScale: 12.087,
      thermal: {
        'none': {R: 1.516, C: 735.5},  // measured 2025-04-17
        'max':  {R: 0.311, C: 735.5},  // measured 2025-04-18 w/ large desk fan
      },
      // The following iron loss model was generated from pypowertrain and is
      // not from any measured or design values.
      d0: 0.04132,
      d1: 0.002403,
      productInfo: '[product page]',
    });
  }
}

class GBM5208 extends Motor {
  constructor() {
    super({
      name: 'gbm5208',
      displayName: 'Rctimer GBM5208',
      maxTemp: 80,
      Kv: 25.5,
      R: 7.545,
      L: 2254.5e-6,
      mass_kg: 0.193,
      // We'll assume saturation isn't relevant for this gimbal wound motor.
      thermal: {
        // Assume this is basically the same as the mj5208, since mounting a
        // thermistor in the coils is basically impossible.
        'none': {R: 4.55, C: 165},
        'max':  {R: 0.5,  C: 165},
      },
      // The following iron loss model is roughly similar to the mj5208, as
      // the stators and magnets are somewhat similar.
      d0: 0.05,
      d1: 0.003,
      productInfo: '[product page]',
    });
  }
}

class BE8108 extends Motor {
  constructor() {
    super({
      name: 'be8108',
      displayName: 'be8108',
      maxTemp: 80,
      Kv: 135,
      R: 0.0910,
      L: 39.2e-6,
      rotationCurrentCutoff: 20.50,
      rotationCurrentScale: 0.04212,
      rotationTorqueScale: 1.0255,
      thermal: {
        'none': {R: 2.74, C: 210.9},  // measured 2025-04-19
        'max':  {R: 0.27, C: 210.9},  // measured 2025-04-19 w/ big desk fan
      },
      // Zero for now, as I have no clue.
      d0: 0.0,
      d1: 0.0,
      productInfo: '[product page]',
    });
  }
}

class Hoverboard350 extends Motor {
  constructor() {
    super({
      name: 'hoverboard350',
      displayName: '8.5" 350W hoverboard',
      maxTemp: 80,
      Kv: 18.2,
      R: 0.216,
      L: 530e-6,
      mass_kg: 4.26,
      // No clue about saturation here yet, it is hard to mount in the dyno.
      thermal: {
        'none': {R: 2.41, C: 946.1},
        'max': {R: 1.80, C: 946.1},
      },
      // Totally arbitrary
      d0: 0.05,
      d1: 0.003,
      productInfo: '[product page]',
    });
  }
}

class HT1105 extends Motor {
  constructor() {
    super({
      name: 'ht1105',
      displayName: 'HT1105',
      maxTemp: 80,
      Kv: 1180,
      R: 6.435,
      L: 298.5e-6,
      mass_kg: 0.008,
      // i suspect due to its gimbal winding, no real saturation effects were
      // measured here all the way up to 2A of phase current.
      thermal: {
        'none': {R: 20.8, C: 14.8},
        'max':  {R: 3.2,  C: 14.8},
      },
      // Zero for now, as I have no clue.
      d0: 0.0,
      d1: 0.0,
      productInfo: '[product page]',
    });
  }
}

class MoteusN1 extends MoteusController {
  constructor() {
    super({
      name: 'moteus-n1',
      maxTemp: 60.0,
      maxCurrent: 100.0,
      maxVoltage: 54.0,
      P_l_W: 2000.0,
      V_l: 36.0,
      P_h_W: 1000.0,
      V_h: 44.0,
      defaultPwm: 30000,
      productInfo: '[product page]',
    },
    {
      'voltages' : [12, 24, 36, 48, 54],
      'pwms' : [15000, 30000, 40000, 60000],
      'k0' : [[0.681, 1.102, 1.467, 1.799, 2.063],
              [0.884, 1.470, 1.983, 2.612, 2.862],
              [1.025, 1.671, 2.302, 3.068, 3.559],
              [1.203, 2.146, 3.036, 3.400, 4.000]],
      'k1' : [[0.016, 0.013, 0.020, 0.032, 0.000],
              [0.033, 0.027, 0.049, 0.073, 0.079],
              [0.023, 0.055, 0.093, 0.112, 0.120],
              [0.055, 0.076, 0.131, 0.140, 0.150]],
      'k2' : [[0.011, 0.012, 0.012, 0.013, 0.016],
              [0.012, 0.014, 0.015, 0.015, 0.018],
              [0.013, 0.014, 0.015, 0.014, 0.030],
              [0.014, 0.018, 0.019, 0.022, 0.035]],
    },
    {
      'none' :         {R: 11.7, C:10.3},
      '5vfan' :        {R: 4.1,  C:10.3},
      'heatspreader':  {R: 9.8,  C:12.2},
      'heatspreader_4030sink': {R:7.2, C:16.8},
      'max':           {R: 3.0,  C:10.3},
    });
  }
}

class MoteusX1 extends MoteusController {
  constructor() {
    super({
      name: 'moteus-x1',
      maxTemp: 100.0,
      maxCurrent: 120.0,
      maxVoltage: 54.0,
      P_l_W: 2000.0,
      V_l: 36.0,
      P_h_W: 1000.0,
      V_h: 44.0,
      defaultPwm: 20000,
      productInfo: '[product page]',
    },
    {
      'voltages' : [12, 24, 36, 48, 54],
      'pwms' : [15000, 20000, 24000, 30000, 40000, 60000],
      'k0' : [[0.615, 0.983, 1.266, 1.501, 1.652],
              [0.744, 1.025, 1.468, 1.825, 2.051],
              [0.822, 1.325, 1.618, 2.025, 2.321],
              [1.119, 1.403, 1.824, 2.326, 2.622],
              [1.135, 1.662, 2.251, 2.811, 3.253],
              [1.465, 2.222, 3.094, 4.130, 4.501]],
      'k1' : [[0.075, 0.090, 0.105, 0.133, 0.133],
              [0.094, 0.128, 0.136, 0.137, 0.137],
              [0.094, 0.124, 0.160, 0.180, 0.172],
              [0.090, 0.163, 0.208, 0.213, 0.223],
              [0.148, 0.227, 0.253, 0.278, 0.247],
              [0.213, 0.317, 0.354, 0.192, 0.286]],
      'k2' : [[0.007, 0.008, 0.010, 0.010, 0.011],
              [0.007, 0.008, 0.011, 0.014, 0.015],
              [0.009, 0.010, 0.013, 0.015, 0.017],
              [0.010, 0.011, 0.014, 0.019, 0.021],
              [0.010, 0.012, 0.021, 0.026, 0.037],
              [0.014, 0.023, 0.043, 0.090, 0.083]],
    },
    {
      'none' :         {R: 8.1, C:14.8},
      '5vfan' :        {R: 2.8, C:14.8},
      '12vfan' :       {R: 2.1, C:14.8},
      'heatspreader_4010sink': { R:7.2, C:16.8},
      'heatspreader_4030sink': { R:6.0, C:20.0},
      'heatspreader':  {R: 8.6, C:14.8},
      'max' :          {R: 1.9, C:14.8},
    });
  }
}

class OdrivePro extends OdriveController {
  constructor() {
    super({
      name: 'odrive-pro',
      maxTemp: 95,
      maxCurrent: 120.0,
      maxCurrentDerateVoltage: 100.0,
      derateCurrent: 120.0,
      maxVoltage: 58.0,
      P_W: 5000.0,
      productInfo: '[product page]',
    },
    {
      voltages: [12, 24, 36, 48, 54],
      pwms: [24000],
      'k0': [[1.410, 1.996, 2.362, 2.823, 3.030]],
      'k1': [[0.091, 0.115, 0.145, 0.161, 0.156]],
      'k2': [[0.008, 0.009, 0.010, 0.010, 0.012]],
    },
    {
      'none':         {R: 6.7, C: 30.4},
      'heatspreader': {R: 5.4, C: 71.7},
      '5vfan':        {R: 1.5, C: 71.7 },
      '12vfan':       {R: 1.0, C: 71.7 },
      'max':          {R: 1.0, C: 71.7},
    });
  }
}

class OdriveS1 extends OdriveController {
  constructor() {
    super({
      name: 'odrive-s1',
      maxTemp: 95.0,
      maxCurrent: 80.0,
      maxCurrentDerateVoltage: 36.0,
      derateCurrent: 40.0,
      maxVoltage: 50.5,
      P_W: 2000.0,
      productInfo: '[product page]',
    },
    {
      voltages: [12, 24, 36, 48],
      pwms: [24000],
      'k0': [[0.839, 1.037, 1.213, 1.328 ]],
      'k1': [[0.066, 0.117, 0.153, 0.179 ]],
      'k2': [[0.008, 0.008, 0.008, 0.008 ]],
    },
    {
      'none':  {R: 6.6, C: 35.8},
      'heatspreader': {R: 4.7, C: 85.8},
      '5vfan': {R: 1.2, C: 85.8},
      'max':   {R: 1.2, C: 85.8},
    });
  }

  getSpeedFactor() {
    return 0.75;
  }
}

class OdriveMicro extends OdriveController {
  constructor() {
    super({
      name: 'odrive-micro',
      maxTemp: 80.0,
      maxCurrent: 7.0,
      maxCurrentDerateVoltage: 100.0,
      derateCurrent: 40.0,
      maxVoltage: 31.0,
      P_W: 100.0,
      productInfo: '[product page]',
    },
    {
      voltages: [12, 24],
      pwms: [24000],
      'k0': [[0.607, 0.820]],
      'k1': [[0.082, 0.301]],
      'k2': [[0.148, 0.149]],
    },
    {
      'none':  {R: 16.0, C: 7.9},
      'max':   {R: 6.2, C: 10.0},
    });
  }

  getSpeedFactor() {
    return 0.75;
  }
}

class AnalysisMaxCurrent {
  evaluate(config) {
    const [R, C] = config.controller.getThermalProperties(config.controller_cooling);
    const timePeriodS = config.time;
    const controllerMaxTemp = config.max_controller_temp == 'default' ? config.controller.getMaxTemp() : config.max_controller_temp;
    const deltaT = controllerMaxTemp - config.ambient_temp;

    if (config.voltage > config.controller.getMaxVoltage()) {
      return null;
    }

    const thermalW = (timePeriodS == Infinity) ? (deltaT / R) :
          (deltaT) / (R * (1.0 - Math.exp(-timePeriodS / (R * C))));

    const result = config.controller.getCurrentFromThermalPower(thermalW, config);

    if (result < 0) {
      return null;
    }

    return new OperatingPoint({
      phase_current: result,
      controller_temp: controllerMaxTemp,
      controller_loss: thermalW,
    });
  }
}

/* ---------- Reusable ConfigFieldSelector Component ---------- */
function ConfigFieldSelector({
  selected,
  onSelectedChange,
  disabled = false,
  placeholder = "Select or create fields..."
}) {
  const [inputValue, setInputValue] = useState('');

  /* utility – already have this field? */
  const fieldTaken = (f) => selected.some((s) => s.field === f);

  /* Generate dynamic options based on current input */
  const getCurrentOptions = () => {
    const kv = parseKV(inputValue);
    const baseFields = getBaseFields(selected);

    // If no '=' found, show base fields
    if (!kv || kv.data === undefined) {
      return baseFields;
    }

    // If field has constrained values, show all or filtered options
    const fieldOptions = fieldValueOptions[kv.field];
    if (fieldOptions) {
      // Show all options if data is empty (just typed '='), otherwise filter
      const filteredOptions = kv.data === '' ? fieldOptions :
        fieldOptions.filter(value => value.toLowerCase().includes(kv.data.toLowerCase()));

      return filteredOptions.map(value => ({
        field: kv.field,
        value: kv.field,
        data: value,
        label: `${kv.field}=${value}`
      }));
    }

    // For unconstrained fields, return base fields
    return baseFields;
  };

  /* --- callbacks passed to <Creatable> --- */
  const getNewOptionData = (input) =>
    parseKV(input) ?? { field: input, value: input, label: input };

  const isValidNewOption = (input) => {
    const kv = parseKV(input);
    if (!kv) return false;

    // Check if the field is in our allowed list
    const baseFields = getBaseFields(selected);
    const isValidField = baseFields.some(bf => bf.field === kv.field);

    if (!isValidField || fieldTaken(kv.field)) {
      return false;
    }

    // For constrained fields, check if the value is allowed
    if (kv.data !== undefined && fieldValueOptions[kv.field]) {
      const allowedValues = fieldValueOptions[kv.field];
      return allowedValues.includes(kv.data);
    }

    // For unconstrained fields or fields without values, allow
    return true;
  };

  const isOptionDisabled = (opt) => fieldTaken(opt.field);

  /* crucial: actually add the newly-typed chip */
  const onCreateOption = (input) => {
    const kv = parseKV(input);
    if (!kv || fieldTaken(kv.field)) return;    // guard
    onSelectedChange([...selected, kv]);
    setInputValue('');
  };

  const handleInputChange = (input, { action }) => {
    if (action === 'input-change') {
      setInputValue(input);
    }
    return input;
  };

  const handleChange = (newValue) => {
    onSelectedChange(newValue);
    setInputValue(''); // Clear input after selection
  };

  // Custom styles for chips based on field type
  const getChipStyles = () => ({
    multiValue: (styles, { data }) => {
      let backgroundColor = styles.backgroundColor;
      if (data.field === 'analysis') {
        backgroundColor = '#d4f4dd'; // Tame green
      } else if (data.field === 'output') {
        backgroundColor = '#dae8fc'; // Tame blue
      }
      return {
        ...styles,
        backgroundColor,
      };
    },
    multiValueLabel: (styles, { data }) => {
      let color = styles.color;
      if (data.field === 'analysis') {
        color = '#2d5a3d'; // Darker green text
      } else if (data.field === 'output') {
        color = '#1e3a5f'; // Darker blue text
      }
      return {
        ...styles,
        color,
      };
    },
  });

  return html`
    <${Creatable}
        isMulti
        isDisabled=${disabled}
        value=${selected}
        onChange=${handleChange}
        placeholder=${placeholder}
        options=${getCurrentOptions()}
        getNewOptionData=${getNewOptionData}
        isValidNewOption=${isValidNewOption}
        onCreateOption=${onCreateOption}
        isOptionDisabled=${isOptionDisabled}
        formatCreateLabel=${(v) => `add ${v}`}
        onInputChange=${handleInputChange}
        inputValue=${inputValue}
        styles=${getChipStyles()}
      />
  `;
}

/* ---------- Panel Components ---------- */
function CommonConfigPanel({ selected, onSelectedChange }) {
  return html`
    <div class="panelContainer">
      <div class="panelTitle">Common Config</div>
      <div class="panelContent">
        <${ConfigFieldSelector}
          selected=${selected}
          onSelectedChange=${onSelectedChange}
          placeholder="Add common configuration..."
        />
      </div>
    </div>
  `;
}

function AxisPanel({ axisNumber, configs, onConfigsChange }) {
  const handleConfigChange = (index, newValue) => {
    let newConfigs = [...configs];
    newConfigs[index] = newValue;

    // If this is the last (empty) field and user added something, add a new empty field
    if (index === configs.length - 1 && newValue.length > 0) {
      newConfigs.push([]);
    }

    // Remove empty fields that are not the last one
    newConfigs = newConfigs.filter((config, i) => {
      // Keep the last field (even if empty) and any non-empty fields
      return i === newConfigs.length - 1 || config.length > 0;
    });

    // Ensure we always have at least one field (empty if needed)
    if (newConfigs.length === 0) {
      newConfigs = [[]];
    }

    onConfigsChange(newConfigs);
  };

  return html`
    <div class="panelContainer">
      <div class="panelTitle">Axis ${axisNumber}</div>
      <div class="panelContent">
        ${configs.map((config, index) => html`
          <div key=${index} class="configField">
            <${ConfigFieldSelector}
              selected=${config}
              onSelectedChange=${(newValue) => handleConfigChange(index, newValue)}
              placeholder=${index === configs.length - 1 ? `Add new axis ${axisNumber} configuration...` : `Axis ${axisNumber} configuration...`}
            />
          </div>
        `)}
      </div>
    </div>
  `;
}

/* ---------- Model Registry ---------- */
const modelRegistry = {
  controller: {
    'moteus-c1': new MoteusC1(),
    'moteus-r4': new MoteusR4(),
    'moteus-n1': new MoteusN1(),
    'moteus-x1': new MoteusX1(),
    'odrive-pro': new OdrivePro(),
    'odrive-s1': new OdriveS1(),
    'odrive-micro': new OdriveMicro(),
  },
  motor: {
    'mj5208': new MJ5208(),
    'mad8318': new MAD8318(),
    'gbm5208': new GBM5208(),
    'be8108': new BE8108(),
    'hoverboard350': new Hoverboard350(),
    'ht1105': new HT1105(),
  },
  analysis: {
    'max_current': new AnalysisMaxCurrent(),
  },
};

/* ---------- Evaluation Function ---------- */
function evaluate(config) {
  config.pwm = config.pwm == 'default' ? config.controller.getDefaultPwm() : config.pwm;
  const op = config.analysis.evaluate(config);
  if (op == null) {
    return '';
  }
  const result = op[config.output];
  if (result == null) {
    return '';
  }
  return result.toFixed(2);
}

/* ---------- Simulator Component ---------- */
function Simulator({ commonConfig, axisConfigs }) {
  // Convert chip array to key-value dictionary
  const convertChipsToDict = (chips) => {
    const dict = {};
    chips.forEach(chip => {
      if (chip.field) {
        dict[chip.field] = chip.data !== undefined ? chip.data : null;
      }
    });
    return dict;
  };

  // Convert string values to model instances where applicable
  const reifyObjects = (dict) => {
    const reified = {};
    Object.entries(dict).forEach(([key, value]) => {
      if (value === null) {
        reified[key] = null;
      } else if (modelRegistry[key] && modelRegistry[key][value]) {
        reified[key] = modelRegistry[key][value];
      } else {
        // Try to convert to number if it's a pure number string or infinity
        if (typeof value === 'string') {
          const lowerValue = value.toLowerCase().trim();
          if (lowerValue === 'infinity') {
            reified[key] = Infinity;
          } else {
            const numValue = Number(value);
            if (!isNaN(numValue) && isFinite(numValue) && value.trim() === numValue.toString()) {
              reified[key] = numValue;
            } else {
              reified[key] = value; // Keep as string if not a number
            }
          }
        } else {
          reified[key] = value; // Keep as-is if not a string
        }
      }
    });
    return reified;
  };

  // Restructure configuration data
  const restructureConfig = () => {
    // Convert common config
    const commonDict = convertChipsToDict(commonConfig);
    const commonReified = reifyObjects(commonDict);

    // Convert each axis config
    const axisData = axisConfigs.map((axisConfigs, axisIndex) => {
      // Each axis can have multiple configuration lines
      const axisLines = axisConfigs.map(lineChips => {
        const dict = convertChipsToDict(lineChips);
        return reifyObjects(dict);
      }).filter(dict => Object.keys(dict).length > 0); // Remove empty dictionaries

      return {
        axisNumber: axisIndex + 1,
        configurations: axisLines
      };
    }).filter(axis => axis.configurations.length > 0); // Remove empty axes

    return {
      common: commonReified,
      axes: axisData
    };
  };

  const restructuredConfig = restructureConfig();

  // Generate a short hash for a configuration object
  const hashConfig = (config) => {
    const str = JSON.stringify(config, null, 0);
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash).toString(16).substr(0, 6);
  };

  // Generate axis name and label formatter based on configuration patterns
  const getAxisInfo = (configs) => {
    if (configs.length === 0) {
      return { name: 'Empty', formatLabel: () => 'empty' };
    }

    // Get all unique field names across all configs
    const allFields = new Set();
    configs.forEach(config => {
      Object.keys(config).forEach(field => allFields.add(field));
    });

    const fieldArray = Array.from(allFields).sort();

    // Check if all configs have exactly one field and it's the same field
    const singleField = fieldArray.length === 1 &&
      configs.every(config => Object.keys(config).length === 1 && config[fieldArray[0]] !== undefined);

    if (singleField) {
      return {
        name: fieldArray[0],
        formatLabel: (config) => config[fieldArray[0]] || 'null'
      };
    } else {
      return {
        name: fieldArray.join(', '),
        formatLabel: (config) => {
          const values = fieldArray.map(field => config[field] || 'null');
          return values.join(', ');
        }
      };
    }
  };

  // Generate cartesian product of additional axes (beyond first 2)
  const cartesianProduct = (arrays) => {
    if (arrays.length === 0) return [[]];
    return arrays.reduce((acc, current) => {
      return acc.flatMap(accItem =>
        current.map(currentItem => [...accItem, currentItem])
      );
    }, [[]]);
  };

  // Generate tables for simulation
  const generateTables = () => {
    const { common, axes } = restructuredConfig;

    if (axes.length === 0) {
      return [{
        title: "No axes configured",
        rows: [],
        columns: [],
        cells: []
      }];
    }

    // Get axis configurations (reified objects)
    const axis1Configs = axes[0]?.configurations || [];
    const axis2Configs = axes[1]?.configurations || [];
    const additionalAxes = axes.slice(2);

    // Get pre-reified configurations for labeling
    const axis1PreReified = axisConfigs[0]?.map(lineChips => convertChipsToDict(lineChips)).filter(dict => Object.keys(dict).length > 0) || [];
    const axis2PreReified = axisConfigs[1]?.map(lineChips => convertChipsToDict(lineChips)).filter(dict => Object.keys(dict).length > 0) || [];

    // Single axis case - single column table
    if (axes.length === 1) {
      const axis1Info = getAxisInfo(axis1PreReified);
      return [{
        title: axis1Info.name,
        rows: axis1Configs,
        columns: [{}], // Single empty column
        cells: generateCells(common, axis1Configs, [{}], {}),
        axis1Info,
        axis1PreReified
      }];
    }

    // Two axes case or more
    if (additionalAxes.length === 0) {
      const axis1Info = getAxisInfo(axis1PreReified);
      const axis2Info = getAxisInfo(axis2PreReified);
      return [{
        title: `${axis1Info.name} vs ${axis2Info.name}`,
        rows: axis1Configs,
        columns: axis2Configs,
        cells: generateCells(common, axis1Configs, axis2Configs, {}),
        axis1Info,
        axis2Info,
        axis1PreReified,
        axis2PreReified
      }];
    }

    // Generate cartesian product for additional axes
    const additionalConfigs = additionalAxes.map(axis => axis.configurations);
    const combinations = cartesianProduct(additionalConfigs);

    // Generate one table per combination
    const axis1Info = getAxisInfo(axis1PreReified);
    const axis2Info = getAxisInfo(axis2PreReified);

    return combinations.map((combination, index) => {
      // Build additional config from combination
      const additionalConfig = {};
      combination.forEach((config, axisIndex) => {
        Object.assign(additionalConfig, config);
      });

      // Generate title showing additional axes
      const additionalTitle = combination.length > 0 ?
        ` (${combination.map((config, i) => `Axis ${i + 3}: ${hashConfig(config)}`).join(', ')})` :
        '';

      return {
        title: `${axis1Info.name} vs ${axis2Info.name}${additionalTitle}`,
        rows: axis1Configs,
        columns: axis2Configs,
        cells: generateCells(common, axis1Configs, axis2Configs, additionalConfig),
        axis1Info,
        axis2Info,
        axis1PreReified,
        axis2PreReified
      };
    });
  };

  // Generate cells for a table
  const generateCells = (common, rows, columns, additionalConfig) => {
    return rows.map(rowConfig => {
      return columns.map(colConfig => {
        // Union of configs: common < additional < axis1 < axis2
        const cellConfig = {
          ...common,
          ...additionalConfig,
          ...rowConfig,
          ...colConfig
        };
        return {
          config: cellConfig,
          result: evaluate(cellConfig)
        };
      });
    });
  };

  const tables = generateTables();

  return html`
    <div>
      <h3>Simulator Results</h3>
      ${tables.map(table => html`
        <div key=${table.title} style="margin-bottom: 2rem;">
          <h4>${table.title}</h4>
          ${table.rows.length === 0 || table.columns.length === 0 ?
            html`<p>No configurations to display</p>` :
            html`
              <table style="border-collapse: collapse; border: 1px solid #ccc;">
                <thead>
                  <tr>
                    ${table.columns.length === 1 && Object.keys(table.columns[0]).length === 0 ?
                      html`
                        <th style="border: 1px solid #ccc; padding: 8px;">${table.axis1Info?.name || 'Axis 1'}</th>
                        <th style="border: 1px solid #ccc; padding: 8px;">Result</th>
                      ` :
                      html`
                        <th style="border: 1px solid #ccc; padding: 8px;">${table.axis1Info?.name || 'Axis 1'} \\ ${table.axis2Info?.name || 'Axis 2'}</th>
                        ${table.columns.map((colConfig, colIndex) => html`
                          <th key=${hashConfig(colConfig)} style="border: 1px solid #ccc; padding: 8px;">
                            ${table.axis2Info?.formatLabel && table.axis2PreReified?.[colIndex] ?
                              table.axis2Info.formatLabel(table.axis2PreReified[colIndex]) :
                              hashConfig(colConfig)}
                          </th>
                        `)}
                      `
                    }
                  </tr>
                </thead>
                <tbody>
                  ${table.rows.map((rowConfig, rowIndex) => html`
                    <tr key=${hashConfig(rowConfig)}>
                      ${table.columns.length === 1 && Object.keys(table.columns[0]).length === 0 ?
                        html`
                          <td style="border: 1px solid #ccc; padding: 8px; font-weight: bold;">
                            ${table.axis1Info?.formatLabel && table.axis1PreReified?.[rowIndex] ?
                              table.axis1Info.formatLabel(table.axis1PreReified[rowIndex]) :
                              hashConfig(rowConfig)}
                          </td>
                          <td style="border: 1px solid #ccc; padding: 8px;">
                            ${table.cells[rowIndex][0].result}
                          </td>
                        ` :
                        html`
                          <td style="border: 1px solid #ccc; padding: 8px; font-weight: bold;">
                            ${table.axis1Info?.formatLabel && table.axis1PreReified?.[rowIndex] ?
                              table.axis1Info.formatLabel(table.axis1PreReified[rowIndex]) :
                              hashConfig(rowConfig)}
                          </td>
                          ${table.cells[rowIndex].map((cell, colIndex) => html`
                            <td key=${colIndex} style="border: 1px solid #ccc; padding: 8px;">
                              ${cell.result}
                            </td>
                          `)}
                        `
                      }
                    </tr>
                  `)}
                </tbody>
              </table>
            `
          }
        </div>
      `)}
    </div>
  `;
}

/* ---------- Main App Component ---------- */
function App() {
  const [commonConfig, setCommonConfig] = useState(
    Object.entries(defaultCommonValues).map(([field, value]) => ({
      field,
      value: field,
      data: value,
      label: `${field}=${value}`
    }))
  );
  const [axisConfigs, setAxisConfigs] = useState(() => {
    const createChip = (field, data) => ({ field, value: field, data, label: `${field}=${data}` });
    return [
      // Axis 1: Controllers
      [
        ...['moteus-c1', 'moteus-r4', 'moteus-n1', 'moteus-x1'].map(controller => [createChip('controller', controller)]),
        [] // Empty line for adding more
      ],
      // Axis 2: Voltages
      [
        ...['12', '24', '36', '48', '54'].map(voltage => [createChip('voltage', voltage)]),
        [] // Empty line for adding more
      ],
      [[]] // Empty axis 3 for adding more axes
    ];
  });

  const handleAxisConfigChange = (axisIndex, newConfigs) => {
    let newAxisConfigs = [...axisConfigs];
    newAxisConfigs[axisIndex] = newConfigs;

    // If this is the last axis and it has any content, add a new empty axis
    if (axisIndex === axisConfigs.length - 1 && hasAnyContent(newConfigs)) {
      newAxisConfigs.push([[]]);  // Add new axis with one empty config
    }

    // Remove empty axes that are not the last one
    newAxisConfigs = newAxisConfigs.filter((configs, i) => {
      // Keep the last axis (even if empty) and any non-empty axes
      return i === newAxisConfigs.length - 1 || hasAnyContent(configs);
    });

    // Ensure we always have at least one axis (empty if needed)
    if (newAxisConfigs.length === 0) {
      newAxisConfigs = [[[]]];  // One axis with one empty config
    }

    setAxisConfigs(newAxisConfigs);
  };

  // Helper function to check if any config in an axis has content
  const hasAnyContent = (configs) => {
    return configs.some(config => config.length > 0);
  };

  /* optional: watch state while testing */
  useEffect(() => {
    console.log('Common Config:', commonConfig);
    console.log('Axis Configs:', axisConfigs);
  }, [commonConfig, axisConfigs]);

  return html`
    <div class="pageContainer">
      <div class="panelColumn">
        <${CommonConfigPanel}
          selected=${commonConfig}
          onSelectedChange=${setCommonConfig}
        />
        ${axisConfigs.map((configs, axisIndex) => html`
          <${AxisPanel}
            key=${axisIndex}
            axisNumber=${axisIndex + 1}
            configs=${configs}
            onConfigsChange=${(newConfigs) => handleAxisConfigChange(axisIndex, newConfigs)}
          />
        `)}
      </div>
      <div class="resultsColumn">
        <${Simulator}
          commonConfig=${commonConfig}
          axisConfigs=${axisConfigs}
        />
      </div>
    </div>
  `;
}

render(html`<${App} />`, document.body);
  </script>
</head>

<body>
<footer>
  <div>
    moteus Performance Analysis Tool
    | Licensed under Apache 2.0
    | (c) 2025 mjbots Robotic Systems
    | <a href="https://mjbots.com">https://mjbots.com</a>
  </div>
</footer>
</body>

</html>
